<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cube Dodge - Lightweight</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
    #score { position: absolute; top: 20px; left: 20px; color: white; font-size: 1.5rem; }
    #gameover { 
      display:none; 
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      background:#ff4757; color:white; padding:20px; text-align:center; border-radius:10px;
    }
    #gameover button { margin-top:10px; padding:8px 16px; cursor:pointer; border:none; border-radius:6px; background:#0984e3; color:white; }
    #gameover button:hover { background:#74b9ff; }
  </style>
</head>
<body>
<div id="score">Score: 0</div>
<div id="gameover">
  Game Over! <br> Score: <span id="finalScore">0</span><br>
  <button onclick="restartGame()">Restart</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
let scene, camera, renderer, player;
let obstacles = [];
let score = 0;
let speed = 0.03;
let maxObstacles = 6;
let isGameOver = false;
let animationId;

init();
startGame();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
  camera.position.set(0, 2, 5);
  camera.lookAt(0,0,0);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Player
  const geo = new THREE.BoxGeometry(1,1,1);
  const mat = new THREE.MeshBasicMaterial({color:0x00ff00});
  player = new THREE.Mesh(geo, mat);
  player.position.y = 0.5;
  scene.add(player);

  // Light
  scene.add(new THREE.AmbientLight(0xffffff));

  window.addEventListener('keydown', movePlayer);
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function createObstacle() {
  if(obstacles.length >= maxObstacles) return;

  const size = 0.7 + Math.random()*0.3;
  const geo = new THREE.BoxGeometry(size,size,size);
  const mat = new THREE.MeshBasicMaterial({color:0xff0000});
  const ob = new THREE.Mesh(geo, mat);
  ob.position.set((Math.random()-0.5)*4, 0.5, -10);
  obstacles.push(ob);
  scene.add(ob);
}

function movePlayer(e){
  if(isGameOver) return;
  if(e.key==='ArrowLeft') player.position.x -= 0.5;
  if(e.key==='ArrowRight') player.position.x += 0.5;
  player.position.x = Math.max(-2, Math.min(2, player.position.x));
}

function animate(){
  if(isGameOver) return;
  animationId = requestAnimationFrame(animate);

  const playerBox = new THREE.Box3().setFromObject(player);

  for(let i=obstacles.length-1;i>=0;i--){
    let ob = obstacles[i];
    ob.position.z += speed;

    const obBox = new THREE.Box3().setFromObject(ob);
    if(playerBox.intersectsBox(obBox)) return endGame();

    if(ob.position.z > 5){
      scene.remove(ob);
      obstacles.splice(i,1);
      score++;
      document.getElementById('score').textContent = `Score: ${score}`;
    }
  }

  // Occasionally add new obstacle
  if(Math.random()<0.02) createObstacle();

  renderer.render(scene,camera);
}

function startGame(){
  obstacles.forEach(ob=>scene.remove(ob));
  obstacles=[];
  isGameOver=false;
  score=0;
  speed=0.03;
  document.getElementById('score').textContent=`Score: ${score}`;
  document.getElementById('gameover').style.display='none';
  animate();
}

function endGame(){
  isGameOver=true;
  document.getElementById('finalScore').textContent=score;
  document.getElementById('gameover').style.display='block';
}

function restartGame(){ startGame(); }

</script>
</body>
</html>
