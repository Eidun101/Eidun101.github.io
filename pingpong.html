<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Ping Pong</title>
<style>
  :root{--bg:#071428;--fg:#cfe;--accent:#2ee6a6}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#021021,#052033);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial;display:flex;align-items:center;justify-content:center;padding:12px;box-sizing:border-box}
  .wrap{width:100%;max-width:900px;text-align:center}
  canvas{background:linear-gradient(180deg,#001826,#002c3f);display:block;margin:12px auto;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .hud{display:flex;justify-content:space-between;align-items:center;gap:12px;color:var(--fg)}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:#08323a;border:none;color:var(--accent);padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:700}
  .small{font-size:13px;color:#a9d9cc}
  #mobileButtons{display:flex;gap:6px;justify-content:center;margin-top:8px}
  .touchBtn{background:rgba(255,255,255,0.04);border-radius:10px;padding:10px 12px;color:var(--fg);font-weight:700;border:1px solid rgba(255,255,255,0.03)}
  @media (max-width:560px){ canvas{width:100%;height:auto} .hud{flex-direction:column;gap:6px} }
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div style="text-align:left">
        <div style="font-weight:800;font-size:18px">Ping Pong</div>
        <div class="small">W/S = Left | ↑/↓ = Right | Tap buttons for mobile</div>
      </div>
      <div style="font-size:18px">
        <span id="scoreLeft">0</span> &nbsp; — &nbsp; <span id="scoreRight">0</span>
      </div>
      <div class="controls">
        <label class="small" style="margin-right:6px">Mode</label>
        <select id="mode">
          <option value="2p">2 Player</option>
          <option value="1p">1 Player (vs AI)</option>
        </select>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Restart</button>
      </div>
    </div>

    <canvas id="c" width="900" height="520"></canvas>

    <div id="mobileButtons">
      <div style="display:flex;gap:6px">
        <div class="touchBtn" id="leftUp">W▲</div>
        <div class="touchBtn" id="leftDown">S▼</div>
      </div>
      <div style="width:22px"></div>
      <div style="display:flex;gap:6px">
        <div class="touchBtn" id="rightUp">▲</div>
        <div class="touchBtn" id="rightDown">▼</div>
      </div>
    </div>
  </div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreLeftEl = document.getElementById('scoreLeft');
const scoreRightEl = document.getElementById('scoreRight');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const modeSelect = document.getElementById('mode');

let W = canvas.width, H = canvas.height;
let keys = {}, touch = {leftUp:false,leftDown:false,rightUp:false,rightDown:false};

const state = {
  paddleW: 12, paddleH: 110,
  left: { x: 28, y: H/2 - 55, vy:0 },
  right: { x: W - 28 - 12, y: H/2 - 55, vy:0 },
  ball: { x: W/2, y: H/2, r:9, vx: 320 * (Math.random()>0.5?1:-1), vy: 160*(Math.random()*1.2-0.6) },
  scoreL:0, scoreR:0,
  running:true, paused:false, maxScore:5,
  aiEnabled: false
};

function resetRound(servingToRight=true){
  state.left.y = H/2 - state.paddleH/2;
  state.right.y = H/2 - state.paddleH/2;
  state.ball.x = W/2; state.ball.y = H/2;
  const speed = 320;
  state.ball.vx = speed * (servingToRight?1:-1);
  state.ball.vy = 120 * (Math.random()*1.4 - 0.7);
}

function resizeCanvasToDisplay(){
  // keep internal canvas size fixed but scale visually for responsiveness
  const rect = canvas.getBoundingClientRect();
  const scale = Math.min(rect.width / W, 1);
  canvas.style.width = Math.round(W * scale) + 'px';
  canvas.style.height = Math.round(H * scale) + 'px';
}
window.addEventListener('resize', resizeCanvasToDisplay);
resizeCanvasToDisplay();

// input
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

// touch handlers utility
function holdBtn(el, propOn, propOff){
  el.addEventListener('touchstart', e => { e.preventDefault(); touch[propOn]=true; }, {passive:false});
  el.addEventListener('touchend', e => { e.preventDefault(); touch[propOn]=false; }, {passive:false});
  el.addEventListener('mousedown', e => { e.preventDefault(); touch[propOn]=true; });
  window.addEventListener('mouseup', e => { touch[propOn]=false; });
}
holdBtn(document.getElementById('leftUp'),'leftUp');
holdBtn(document.getElementById('leftDown'),'leftDown');
holdBtn(document.getElementById('rightUp'),'rightUp');
holdBtn(document.getElementById('rightDown'),'rightDown');

pauseBtn.addEventListener('click', ()=> {
  state.paused = !state.paused;
  pauseBtn.textContent = state.paused ? 'Resume' : 'Pause';
});

resetBtn.addEventListener('click', ()=> {
  state.scoreL = 0; state.scoreR = 0;
  updateScoreUI();
  resetRound(true);
  state.running = true; state.paused = false;
  pauseBtn.textContent = 'Pause';
});

modeSelect.addEventListener('change', (e)=> {
  const v = e.target.value;
  state.aiEnabled = (v === '1p');
});

// game logic
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function update(dt){
  if (!state.running || state.paused) return;

  // left paddle control: W/S or touch
  let leftMove = 0;
  if (keys['w'] || keys['W'] || touch.leftUp) leftMove -= 1;
  if (keys['s'] || keys['S'] || touch.leftDown) leftMove += 1;

  // right paddle control: arrows or touch; if ai enabled use ai
  let rightMove = 0;
  if (!state.aiEnabled){
    if (keys['ArrowUp'] || touch.rightUp) rightMove -= 1;
    if (keys['ArrowDown'] || touch.rightDown) rightMove += 1;
  } else {
    // simple AI: move toward ball with smoothing and max speed
    const paddleCenter = state.right.y + state.paddleH / 2;
    const diff = state.ball.y - paddleCenter;
    rightMove = clamp(diff / 80, -1, 1); // scaled movement
  }

  const paddleSpeed = 360;
  state.left.y += leftMove * paddleSpeed * dt;
  state.right.y += rightMove * paddleSpeed * dt;
  state.left.y = clamp(state.left.y, 6, H - state.paddleH - 6);
  state.right.y = clamp(state.right.y, 6, H - state.paddleH - 6);

  // move ball
  state.ball.x += state.ball.vx * dt;
  state.ball.y += state.ball.vy * dt;

  // top/bottom collision
  if (state.ball.y - state.ball.r <= 6){ state.ball.y = 6 + state.ball.r; state.ball.vy *= -1; }
  if (state.ball.y + state.ball.r >= H - 6){ state.ball.y = H - 6 - state.ball.r; state.ball.vy *= -1; }

  // paddles collision (left)
  if (state.ball.x - state.ball.r <= state.left.x + state.paddleW){
    if (state.ball.y >= state.left.y && state.ball.y <= state.left.y + state.paddleH){
      state.ball.x = state.left.x + state.paddleW + state.ball.r;
      bounceFromPaddle(state.left);
    }
  }
  // paddles collision (right)
  if (state.ball.x + state.ball.r >= state.right.x){
    if (state.ball.y >= state.right.y && state.ball.y <= state.right.y + state.paddleH){
      state.ball.x = state.right.x - state.ball.r;
      bounceFromPaddle(state.right);
    }
  }

  // score check
  if (state.ball.x < -20){
    state.scoreR += 1; updateScoreUI(); resetRound(true);
  }
  if (state.ball.x > W + 20){
    state.scoreL += 1; updateScoreUI(); resetRound(false);
  }

  // win condition
  if (state.scoreL >= state.maxScore || state.scoreR >= state.maxScore){
    state.running = false;
    setTimeout(()=> {
      alert((state.scoreL > state.scoreR ? 'Left Player' : 'Right Player') + ' wins!\nScore ' + state.scoreL + ' — ' + state.scoreR);
    }, 100);
  }
}

function bounceFromPaddle(paddle){
  // increase speed slightly each hit and change angle depending on where it hit
  const hitPos = (state.ball.y - (paddle.y + state.paddleH/2)) / (state.paddleH/2); // -1..1
  const speed = Math.hypot(state.ball.vx, state.ball.vy);
  const newSpeed = Math.min(720, speed * 1.05 + 10);
  const angle = hitPos * (Math.PI/3); // tilt angle
  const dir = (paddle === state.left) ? 1 : -1;
  state.ball.vx = newSpeed * Math.cos(angle) * dir;
  state.ball.vy = newSpeed * Math.sin(angle);
  // slight nudge to avoid stuck near horizontal
  if (Math.abs(state.ball.vx) < 60) state.ball.vx = 60 * dir;
}

function updateScoreUI(){
  scoreLeftEl.textContent = state.scoreL;
  scoreRightEl.textContent = state.scoreR;
}

// render
function drawRoundRect(x,y,w,h,r,color){
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.fill();
}

function render(){
  // background
  ctx.clearRect(0,0,W,H);
  // center dashed line
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 2;
  ctx.setLineDash([10,14]);
  ctx.beginPath();
  ctx.moveTo(W/2, 8);
  ctx.lineTo(W/2, H-8);
  ctx.stroke();
  ctx.setLineDash([]);

  // paddles
  drawRoundRect(state.left.x, state.left.y, state.paddleW, state.paddleH, 6, '#2ee6a6');
  drawRoundRect(state.right.x, state.right.y, state.paddleW, state.paddleH, 6, '#2ee6a6');

  // ball
  ctx.fillStyle = '#ffd';
  ctx.beginPath(); ctx.arc(state.ball.x, state.ball.y, state.ball.r, 0, Math.PI*2); ctx.fill();

  // scores & small HUD
  ctx.fillStyle = '#cfe';
  ctx.font = '20px system-ui,Segoe UI,Arial';
  ctx.fillText(state.scoreL, W/2 - 60, 36);
  ctx.fillText(state.scoreR, W/2 + 40, 36);
}

// loop
let last = performance.now();
function loop(ts){
  const dt = Math.min(0.03, (ts - last)/1000);
  last = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
resetRound(true);
updateScoreUI();
requestAnimationFrame(loop);

// keyboard guidance: ensure canvas resize handles visual scale
resizeCanvasToDisplay();

// auto-enable AI if selected
state.aiEnabled = (modeSelect.value === '1p');

</script>
</body>
</html>
